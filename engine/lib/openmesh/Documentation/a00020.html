<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>OpenMesh: Specifying your MyMesh</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="logo_align.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rwth_I8_bild_rgb.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenMesh
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00020.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Specifying your MyMesh </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section will show how to build your own custom tailored type <code>MyMesh</code>.</p>
<p>As we have seen in the section on goals and features there are some parameters to be specified for a mesh. This is done in the following four steps:</p>
<ol>
<li>
<p class="startli">Choose between triangle mesh and general polygonal mesh.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Select the mesh kernel</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Parameterize the mesh by a so-called <em>Traits</em> class. You can add arbitrary classes to the mesh items, specify the types <code>Scalar</code>, <code>Point</code>, <code>Normal</code> and <code>Color</code>, and use predefined attributes like <code>Attributes::Normal</code> and <code>Attributes::Color</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Dynamically bind data to the mesh or the mesh entities (vertex, (half-)edge, face) using <em>custom</em> <em>properties</em>.</p>
<p class="endli"></p>
</li>
</ol>
<p>We will explain these four parameterization steps and give a code example at the end of this page.</p>
<p><br />
<br />
</p>
<h1><a class="anchor" id="sec_select_face_type"></a>
Polygonal or Triangle Mesh?</h1>
<p>This decision is quite simple: Whenever possible choose the triangle mesh. The restriction to triangular faces usually leads to more efficient algorithms (e.g. rendering triangles is much faster than rendering arbitrary polygons). Additionally some algorithms are only implemented for triangle meshes while triangle meshes inherit the full functionality of polygonal meshes. For a list of them refer to the following links.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00250.html" title="Base type for a polygonal mesh. ">OpenMesh::PolyMeshT</a> </dd>
<dd>
<a class="el" href="a00284.html" title="Base type for a triangle mesh. ">OpenMesh::TriMeshT</a></dd></dl>
<p><br />
<br />
</p>
<h1><a class="anchor" id="sec_select_kernel"></a>
Choosing the right kernel</h1>
<p>The mesh kernel specifies how the mesh entities (vertices, (half-)edges, faces) are internally stored. In fact the entities are kept in so-called properties. A property itself provides an array like interface. The kernel defines the corresponding handle types, i.e. the way items reference each other. Since the properties have an array like interface the handles are represented internally as indices.</p>
<p>The default kernel is <code>ArrayKernelT</code>. Which is good for most situations. But depending on the application a different kernel would be better. E.g. the OpenSG integration has been realized be replacing the kernel by a custom kernel, since OpenSG provides already array like properties, which could be reused for the intergration. In case of a an OpenSG environment one might be better off using <code>OSG_Kernel::ArrayKernelT</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00754.html">Mesh Kernels</a></dd></dl>
<p><br />
<br />
</p>
<h1><a class="anchor" id="sec_select_traits"></a>
Mesh Traits</h1>
<p>While the last two sections only have chosen from a list of predefined meshes or kernels, respectively, we now come to the user-defined customization.</p>
<p>The resulting mesh <code>MyMesh</code> will provide the following types:</p>
<ul>
<li>
The <em>point</em> and <em>scalar</em> type: <code><a class="el" href="a00250.html#aed10fb4dfb536b53a5e20c8f2442eadf" title="Coordinate type. ">MyMesh::Point</a></code> and <code><a class="el" href="a00250.html#a15372f27edf521d8e9028e2abccae342" title="Scalar type. ">MyMesh::Scalar</a></code>. </li>
<li>
The <em>mesh items</em>: <code><a class="el" href="a00250.html#a03e6fd1a2fc91d4144374fd28dfbecee" title="Vertex type. ">MyMesh::Vertex</a></code>, <code><a class="el" href="a00250.html#a249b0c195a81eeab341f7f73089d157e" title="Halfedge type. ">MyMesh::Halfedge</a></code>, <code><a class="el" href="a00250.html#ab2ccdc42b7b25cf35915d3639fc461b2" title="Edge type. ">MyMesh::Edge</a></code>, <code><a class="el" href="a00250.html#a71e1e8eaabeb24eca04237931b4bea26" title="Face type. ">MyMesh::Face</a></code>. </li>
<li>
The <em>handle</em> types: <code><a class="el" href="a00250.html#a0fc18e13d70825938274e3faf7b55e01" title="Handle for referencing the corresponding item. ">MyMesh::VertexHandle</a></code>, <code>MyMesh::HalfedgeHandle</code>, <code>MyMesh::EdgeHandle</code>, <code>MyMesh::FaceHandle</code>. </li>
</ul>
<p>While the handle types are fixed, the other types can be customized. Each mesh type (see <a class="el" href="a00755.html">Predefined Mesh Types</a>) can be parameterized by a so-called <em>traits</em> class. Using this mechanism one can</p>
<ol>
<li>
change the coordinate type <code><a class="el" href="a00250.html#aed10fb4dfb536b53a5e20c8f2442eadf" title="Coordinate type. ">MyMesh::Point</a></code> and the resulting scalar type <code><a class="el" href="a00250.html#a15372f27edf521d8e9028e2abccae342" title="Scalar type. ">MyMesh::Scalar</a></code> == <code>MyMesh::Point::value_type</code>, </li>
<li>
change the normal type <code><a class="el" href="a00250.html#a3570fd132d1ac589b380485cf59c9e0b" title="Normal type. ">MyMesh::Normal</a></code> </li>
<li>
change the color type <code><a class="el" href="a00250.html#af0d8129bf1a819c468c6edcb13b5203b" title="Color type. ">MyMesh::Color</a></code> </li>
<li>
use predefined attributes like normal vector, color, texture coordinates, ... for the mesh items. </li>
<li>
add arbitrary classes to the mesh items. </li>
</ol>
<p>All these customizations are encapsulated in one class <code><a class="el" href="a00232.html">MyTraits</a></code>, that is used as template argument to the mesh, e.g. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="a00232.html">MyTraits</a> {</div>
<div class="line">  <span class="comment">// your customization</span></div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> PolyMesh_ArrayKernelT&lt;MyTraits&gt;  <a class="code" href="a00249.html">MyMesh</a>;</div>
</div><!-- fragment --><p>The rest of this section explains the construction of this traits class, its application to the mesh will be the topic of the next section.</p>
<p>For each mesh entity one can control the predefined attributes to be attached by a traits class using some convenience macros, e.g. <code>OpenMesh::VertexAttributes</code> and <code>OpenMesh::VertexTraits</code> for vertices. The default traits class looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DefaultTraits</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> Vec3f  Point;</div>
<div class="line">  <span class="keyword">typedef</span> Vec3f  <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96da213616dd2e4d9744d863587001a77988">Normal</a>;</div>
<div class="line">  <span class="keyword">typedef</span> Vec2f  TexCoord;</div>
<div class="line">  <span class="keyword">typedef</span> Vec3uc <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96dad51534b15e5d0f65569251f4cb3c0d0c">Color</a>;</div>
<div class="line"></div>
<div class="line">  <a class="code" href="a00506.html#aa5146d858418fcb93715406a6ce8e30f">VertexTraits</a>    {};</div>
<div class="line">  <a class="code" href="a00506.html#a223434df0f07f8e05b89324094fc1de8">HalfedgeTraits</a>  {};</div>
<div class="line">  <a class="code" href="a00506.html#adbd10edc9787f8347769a11391896d9e">EdgeTraits</a>      {};</div>
<div class="line">  <a class="code" href="a00506.html#a48a58bb27b065ea6b5f6e973756f1800">FaceTraits</a>      {};</div>
<div class="line">  </div>
<div class="line">  <a class="code" href="a00506.html#a427ff443d5e47c76b9c45a29213e63db">VertexAttributes</a>(0);</div>
<div class="line">  <a class="code" href="a00506.html#a72688ff15a275a41a98159ce72eaab4f">HalfedgeAttributes</a>(<a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96dafaaebe1808b5cce96ad4e19df471d58a">Attributes::PrevHalfedge</a>);</div>
<div class="line">  <a class="code" href="a00506.html#a8126b6d66b0b65c5e23e8856c6092c28">EdgeAttributes</a>(0);</div>
<div class="line">  <a class="code" href="a00506.html#a75f0d731abf2489208086aac5147eefc">FaceAttributes</a>(0);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Please note that for example <code>VertexTraits</code> is a define concealing a template declaration. The actual template class name is <code>VertexT</code>, which is further simplified to a specific type <code>Vertex</code> at a later stage during the construction of the mesh kernel.</p>
<p>Because the traits classes always have to provide the template classes <code>VertexT</code>, <code>HalfedgeT</code>, <code>EdgeT</code>, <code>FaceT</code>, and the types <code>Point</code>, <code>Normal</code>, <code>Color</code>, and <code>TexCoord</code> one should derive this class from the default implementation <code>DefaultTraits</code>. In this case you will only have to define the classes or types you want to override or substitute.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sec_change_point"></a>
Changing the Point type</h2>
<p>Changing the type that is used to store the point coordinates as well as the normal vectors can simply be done by defining this type in the traits class. The following code changes the coordinate type in order to use <code>double</code> instead of <code>float</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="a00232.html">MyTraits</a> : <span class="keyword">public</span> <a class="code" href="a00131.html">OpenMesh::DefaultTraits</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> OpenMesh::Vec3d Point; <span class="comment">// use double-values points</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Using the OpenMesh::VectorT class you can easily plug in any scalar type for the use in point coordinates, e.g. some exact arithmetic. You can also exchange the whole class representing points as long as it provides the same interface as the OpenMesh::VectorT class.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sec_add_attributes"></a>
Adding Predefined Attributes</h2>
<p>There are some pre-defined attributes that can be appended to the mesh items. These global attributes are defined in the namespace <a class="el" href="a00731.html" title="This namespace holds per item attributes like normal/color. ">OpenMesh::Attributes</a>. The advantage of these attributes is that they are registered at the items they are added to. Therefore algorithms can check for these attributes at run-time as well as at compile-time. This is important if you want to implement algorithms acting on different meshes, that may or may not have e.g. normal vectors per vertex/face.</p>
<p>Adding these predefined attributes is quite simple. You provide an <code>unsigned int</code> in the traits class, whose bits control whether or not a certain attribute should be attached or not.</p>
<p>If you want to add a normal vector to your vertices and faces, and also want to have color information for vertices, the code would look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="a00232.html">MyTraits</a> : <span class="keyword">public</span> <a class="code" href="a00131.html">OpenMesh::DefaultTraits</a> </div>
<div class="line">{</div>
<div class="line">  VertexAttributes( <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96da213616dd2e4d9744d863587001a77988">OpenMesh::Attributes::Normal</a> |</div>
<div class="line">                    <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96dad51534b15e5d0f65569251f4cb3c0d0c">OpenMesh::Attributes::Color</a> );</div>
<div class="line"></div>
<div class="line">  FaceAttributes( <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96da213616dd2e4d9744d863587001a77988">OpenMesh::Attributes::Normal</a> );</div>
<div class="line">};</div>
</div><!-- fragment --><p>Internally each mesh item contains an <code>enum</code> defining the integer <code>Attributes</code> (containing the bits of used attributes OR'ed together). From its set/unset bits you can see whether a certain attribute is used. <a class="el" href="a00730.html" title="Contains all the mesh ingredients like the polygonal mesh, the triangle mesh, different mesh kernels ...">OpenMesh</a> provides the macro OM_Check_Attrib for doing this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (OM_Check_Attrib(<a class="code" href="a00250.html#a03e6fd1a2fc91d4144374fd28dfbecee">MyMesh::Vertex</a>, <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96da213616dd2e4d9744d863587001a77988">Normal</a>)</div>
<div class="line">  do_something_with_normals();</div>
</div><!-- fragment --><p>These run-time checks may not be sufficient in some cases. You can also check for attributes at compile-time and instantiate the correct functions by using function overloading. The class <code>GenProg::Bool2Type</code> maps true/false information to two different types, <code>Bool2Type&lt;true&gt;</code> and <code>Bool2Type&lt;false&gt;</code>. An example that draws OpenGL normals if they are available would look like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;OpenMesh/Core/Utils/GenProg.hh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// draw a face normal if we have one</span></div>
<div class="line"><span class="keywordtype">void</span> drawFaceNormal(<span class="keyword">const</span> <a class="code" href="a00250.html#a71e1e8eaabeb24eca04237931b4bea26">MyMesh::Face</a>&amp; _f) { </div>
<div class="line">  drawFaceNormal(_f, GenProg::Bool2Type&lt;OM_Check_Attrib(<a class="code" href="a00250.html#a71e1e8eaabeb24eca04237931b4bea26">MyMesh::Face</a>, <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96da213616dd2e4d9744d863587001a77988">Normal</a>)&gt;()); </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// normal exists -&gt; use it</span></div>
<div class="line"><span class="keywordtype">void</span> drawFaceNormal(<span class="keyword">const</span> <a class="code" href="a00250.html#a71e1e8eaabeb24eca04237931b4bea26">MyMesh::Face</a>&amp; _f, GenProg::Bool2Type&lt;true&gt;) { </div>
<div class="line">  glNormal3fv(_f.normal());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// empty dummy (no normals)</span></div>
<div class="line"><span class="keywordtype">void</span> drawFaceNormal(<span class="keyword">const</span> <a class="code" href="a00250.html#a71e1e8eaabeb24eca04237931b4bea26">MyMesh::Face</a>&amp; _f, GenProg::Bool2Type&lt;false&gt;){}</div>
</div><!-- fragment --><p>Especially the compile-time checking for attributes is extremely useful because it does not generate any unnecessary code and does not perform expensive tests at run-time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00131.html" title="Base class for all traits. ">OpenMesh::DefaultTraits</a> </dd>
<dd>
<a class="el" href="a00731.html" title="This namespace holds per item attributes like normal/color. ">OpenMesh::Attributes</a> </dd>
<dd>
<a class="el" href="a00734.html" title="Utilities for generative programming. ">OpenMesh::GenProg</a></dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="sec_add_traits"></a>
Adding User-Defined Elements</h2>
<p>You can also add arbitrary types/elements/methods to the mesh items by providing a corresponding traits class for these items. Adding some index to the <code>Vertex</code> class is easily done by</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="a00232.html">MyTraits</a> : <span class="keyword">public</span> <a class="code" href="a00131.html">OpenMesh::DefaultTraits</a></div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00506.html#aa5146d858418fcb93715406a6ce8e30f">VertexTraits</a></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> some_additional_index;</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><p>The macro <code>VertexTraits</code> hides some ugly template stuff. In fact, it is defined as</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define VertexTraits template &lt;class Base, class Refs&gt; struct VertexT : public Base</span></div>
</div><!-- fragment --><p>hence the traits class actually looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="a00232.html">MyTraits</a> : <span class="keyword">public</span> <a class="code" href="a00131.html">OpenMesh::DefaultTraits</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Base, <span class="keyword">class</span> Refs&gt; <span class="keyword">struct </span>VertexT : <span class="keyword">public</span> Base</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> some_additional_index;</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><p>You have to keep this in mind when you want to define constructors for your vertex type or when you want to derive the vertex type from other classes.</p>
<p>The template argument <code>Base</code> provides access to the mesh handles and to the <code>Point</code> and <code>Scalar</code> type by its member class <code>Refs</code>. Adding a <code>MyMesh::FaceHandle</code> to the vertex class can therefore be implemented like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="a00232.html">MyTraits</a> : <span class="keyword">public</span> <a class="code" href="a00131.html">OpenMesh::DefaultTraits</a> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="a00506.html#aa5146d858418fcb93715406a6ce8e30f">VertexTraits</a></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> some_additional_index;</div>
<div class="line">    <span class="keyword">typename</span> Base::Refs::FaceHandle my_face_handle;</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><p>Adding elements to other mesh items works in the same manner.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sec_algo_traits"></a>
Using traits defined by algorithms</h2>
<p>From version 0.10.3 on algorithms can define traits/attributes they require and the user can merge these traits into his own traits. A more elegant way is to use dynamic properites, which can be added/removed during runtime by the algorithm. This is the preferred way to attach custom data to the mesh.</p>
<p>An example for an algorithm as well as the application using traits is given in <a class="el" href="a00056.html">Using mesh attributes and traits</a>.</p>
<p><br />
<br />
</p>
<h1><a class="anchor" id="sec_properties"></a>
Dynamic Properties</h1>
<p>From version 1.0 on OpenMesh provides dynamic properties. Instead of using traits to bind data at compile time algorithms or the application can use dynamic properties. Similar to entities the properties are accessed and manipulated via handles.</p>
<p>An example for an algorithm as well as the application using properties is given in <a class="el" href="a00050.html">Using (custom) properties</a> and <a class="el" href="a00052.html">Using STL algorithms</a>.</p>
<p><br />
<br />
</p>
<h1><a class="anchor" id="sec_traits_example"></a>
Final Implementation Example</h1>
<p>Consider an application where we just want to render triangle meshes. This means we will select the triangle mesh and the <code>ArrayKernelT</code>. Faces that are not triangles will automatically be tesselated into triangles. Because we only display meshes and do not dynamically add or remove items, we can just use the <code>ArrayKernelT</code>.</p>
<p>All mesh-kernel combinations are predefined in the directory <code>OpenMesh/Mesh/Types</code>. Refer to <a class="el" href="a00755.html">Predefined Mesh Types</a> for a complete list of them. For our example we use the <code>TriMesh_ArrayKernelT</code> and parameterize it by our <code><a class="el" href="a00232.html">MyTraits</a></code> class.</p>
<p>We will need face and vertex normals and e.g. for color coding vertex curvature, i.e. vertex color.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh&gt;</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// define traits</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="a00232.html">MyTraits</a> : <span class="keyword">public</span> <a class="code" href="a00131.html">OpenMesh::DefaultTraits</a></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// use double valued coordinates</span></div>
<div class="line">  <span class="keyword">typedef</span> OpenMesh::Vec3d Point;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// use vertex normals and vertex colors</span></div>
<div class="line">  VertexAttributes( <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96da213616dd2e4d9744d863587001a77988">OpenMesh::DefaultAttributer::Normal</a> |</div>
<div class="line">                    <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96dad51534b15e5d0f65569251f4cb3c0d0c">OpenMesh::DefaultAttributer::Color</a> );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// store the previous halfedge</span></div>
<div class="line">  HalfedgeAttributes( <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96dafaaebe1808b5cce96ad4e19df471d58a">OpenMesh::DefaultAttributer::PrevHalfedge</a> );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// use face normals</span></div>
<div class="line">  FaceAttributes( <a class="code" href="a00731.html#ab78a93560926cd2f9958cb028f7ea96da213616dd2e4d9744d863587001a77988">OpenMesh::DefaultAttributer::Normal</a> );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// store a face handle for each vertex</span></div>
<div class="line">  <a class="code" href="a00506.html#aa5146d858418fcb93715406a6ce8e30f">VertexTraits</a></div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">typename</span> Base::Refs::FaceHandle my_face_handle;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Select mesh type (TriMesh) and kernel (ArrayKernel)</span></div>
<div class="line"><span class="comment">// and define my personal mesh type (MyMesh)</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="a00281.html">OpenMesh::TriMesh_ArrayKernelT&lt;MyTraits&gt;</a>  MyMesh;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  MyMesh mesh;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// -------------------- Add dynamic data</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// for each vertex an extra double value</span></div>
<div class="line">  <a class="code" href="a00329.html">OpenMesh::VPropHandleT&lt; double &gt;</a> vprop_double;</div>
<div class="line">  mesh.add_property( vprop_double );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// for the mesh an extra string</span></div>
<div class="line">  <a class="code" href="a00230.html">OpenMesh::MPropHandleT&lt; string &gt;</a> mprop_string;</div>
<div class="line">  mesh.add_property( mprop_string );</div>
<div class="line"></div>
<div class="line">  <span class="comment">// -------------------- do something</span></div>
<div class="line"></div>
<div class="line">  ...;</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>That's it. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
