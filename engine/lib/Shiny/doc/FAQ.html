<html>
<head>
<title>Shiny Profiler FAQ</title>
</head>
<body>

<p><strong>What is Shiny?</strong><br />
<br />
Shiny is a low overhead, well documented and lightning fast C++ profiler. Easy to use on existing projects, no extensive surgery, just have fun with it. Nicely formatted output provides call tree (call graph), flat profile and is simple to custom display.<br />
<br />
<br />
<strong>Why did you create Shiny?</strong><br />
<br />
I was working on a graphics engine and I wanted to see the fruit of my optimizations and growth to each critical part. I needed something accurate, adapted to my main-loop &amp; display and disgusting fast.<br />
<br />
<br />
<strong>What’s the difference between other profilers?</strong><br />
<br />
Most profilers are external tools and can’t adapt to the way your project is designed. The rest aren’t really powerful enough. Shiny can adapt to your code flow and your display by your choice. Optimized to the bone, delivers both call tree/graph and flat profile and is so easy to use you’ll never look at another profiler again.<br />
<br />
<br />
<strong>What features does Shiny support? </strong><br />
<br />
Where are some key features:<br />
•&nbsp;&nbsp; &nbsp;Self-initialized profiler.<br />
•&nbsp;&nbsp; &nbsp;Well documentation and example rich.<br />
•&nbsp;&nbsp; &nbsp;Lightning fast and accurate profiling.<br />
•&nbsp;&nbsp; &nbsp;Ridiculously easy to use and minimal interface: 1 call per profile and 2 calls at minimum.<br />
•&nbsp;&nbsp; &nbsp;Nicely formatted output with customizable display.<br />
•&nbsp;&nbsp; &nbsp;Call-tree with recursion and flat profile layout.<br />
•&nbsp;&nbsp; &nbsp;Average and last time values for frame-loop-based projects.<br />
•&nbsp;&nbsp; &nbsp;Exponential moving average damping factor.<br />
•&nbsp;&nbsp; &nbsp;Negligible memory pool allocation.<br />
•&nbsp;&nbsp; &nbsp;Child, parent and total relationship timing between profiles.<br />
•&nbsp;&nbsp; &nbsp;Platform-independent clean open source code.<br />
<br />
<br />
<strong>How to switch Shiny on and off?</strong><br />
<br />
Shiny is turned on or off at compile time. Define the pre-processor SHINY_PROFILER to TRUE or FALSE to enable or disable, before including header Shiny.h. Shiny can also be enabled or disabled in ShinyConfig.h. Default is on.<br />
<br />
<br />
<strong>Does Shiny support C language?</strong><br />
<br />
No. I currently have no future plans to support C, although it is easy to adapt Shiny for C without touching the interface.<br />
<br />
<br />
<strong>Is Shiny thread-safe?</strong><br />
<br />
Not yet.<br />
<br />
<br />
<strong>Why is profile data zero?</strong><br />
<br />
PROFILER_UPDATE must be called before outputting profile data.<br />
<br />
<br />
<strong>How to output latest profile data instead of averages?</strong><br />
<br />
Set damping to zero when calling PROFILER_UPDATE.<br />
In code: PROFILER_UPDATE(0);<br />
<br />
<br />
<strong>Why is profile data "hit" count a floating-point?</strong></p>
<p>Shiny uses the exponential moving average to calculate floating-point values for the latest profile data values. This can be customized by the damping parameter for PROFILER_UPDATE.<br />
<br />
<br />
<strong>Why is some profile data leaping seconds back or forward in time?</strong><br />
<br />
Your platform has broken support for multi-core or multi-processor high-performance timing. You can solve this in three ways in Windows:<br />
•&nbsp;&nbsp; &nbsp;(Recommended) Download the fix for this from Microsoft website.<br />
•&nbsp;&nbsp; &nbsp;Call SetProcessAffinityMask or SetThreadAffinityMask at start of program to lock to a specific CPU.<br />
•&nbsp;&nbsp; &nbsp;(Not Recommended) Use timeGetTime instead of QueryPerformanceCounter in the Shiny source code.<br />
</p>

</body>
</html>